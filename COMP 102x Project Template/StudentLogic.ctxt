#BlueJ class context
comment0.params=depthImages\ initialStep\ currentStep\ finalStep\ initialScale\ finalScale\ initialX\ finalX\ initialY\ finalY
comment0.target=comp102x.ColorImage\ generateIntermediateFootballImage(comp102x.ColorImage[],\ int,\ int,\ int,\ double,\ double,\ int,\ int,\ int,\ int)
comment0.text=\n\ Generates\ an\ intermediate\ football\ image\ for\ the\ shooting\ animation.\n\ \n\ @param\ depthImages\ The\ array\ contains\ an\ array\ of\ football\ images\ of\ different\ depths.\n\ @param\ initialStep\ The\ initial\ step\ of\ the\ shooting\ animation.\n\ @param\ currentStep\ The\ current\ step\ of\ the\ shooting\ animation\n\ @param\ finalStep\ The\ final\ step\ of\ the\ shooting\ animation.\n\ @param\ initialScale\ The\ initial\ scale\ of\ the\ football\ \n\ @param\ finalScale\ The\ final\ scale\ of\ the\ football\ \n\ @param\ initialX\ The\ initial\ x\ position\ of\ the\ football.\n\ @param\ finalX\ The\ final\ x\ positions\ of\ the\ football.\n\ @param\ initialY\ The\ initial\ y\ position\ of\ the\ football.\n\ @param\ finalY\ The\ final\ y\ positions\ of\ the\ football.\n\ @return\ The\ selected\ depth\ image\ of\ football.\n
comment1.params=goals
comment1.target=void\ updateGoalPositions(comp102x.assignment.Goal[][])
comment1.text=\n\ Method\ implimentation\ <br>\ <br>\ \ \n\ Step0\:\ Variables\ <br>\n\ \ \ \ \ \ \ \ \ \ log\ is\ Goal\ 2D\ array\ to\ keep\ long\ in\ order\ to\ avoid\ reverse\ swap\ in\ the\ same\ call\ of\ the\ method\ <br>\ <br>\n\ Step1\:\ For\ every\ goal\ (array\ cell),\ check\ following\ conditions\ <br>\n\ \ \ \ \ \ \ \ \ \ (A)\:\ Its\ Type\ (movable\ (Type\:1)/stationary(Type\:2))\ <br>\n\ \ \ \ \ \ \ \ \ \ (B)\:\ Its\ Hit\ state\ (True/False)\ <br>\ <br>\n\ Step2\:\ Strategy\ to\ randomly\ generate\ the\ indices\ of\ nearest\ neighbour\ of\ the\ current\ goal\ <br>\n\ \ \ \ \ \ \ \ \ \ (A)\:\ Generate\ random\ number\ between\ -1\ and\ 1\ and\ add\ it\ to\ the\ current\ goal\ i-index.\ That\ is\ row\ index\ (t1)\ of\ nearest\ neighbour\ <br>\n\ \ \ \ \ \ \ \ \ \ (A)\:\ Generate\ random\ number\ between\ -1\ and\ 1\ and\ add\ it\ to\ the\ current\ goal\ j-index.\ That\ is\ column\ index\ (t2)\ of\ nearest\ neighbour\ <br>\ <br>\n\ Step3\:\ Validate\ randomly\ picked\ nearest\ neighbour\ goal\ <br>\n\ \ \ \ \ \ \ \ \ \ (A1)\:\ Check\ the\ indices\ (t1,t2)\ of\ randomaly\ picked\ nearest\ neighbour\ are\ within\ the\ boundaries\ of\ 2D\ array\ such\ that\ following\ conditions\ are\ fullfilled\ <br>\ \n\ \ \ \ \ \ \ \ \ \ Conditions\:\ t1\ >\=\ 0\ (upper\ boundary)\ &&\ t2\ >\=\ 0\ (left\ boundary)\ &&\ t1\ <\ row\ (lower\ boundary)\ &&\ t2\ <\ col\ (right\ boundary)\ <br>\n\ \ \ \ \ \ \ \ \ \ (A2)\:\ If\ the\ current\ goal\ i-index\ and\ t1\ are\ similar\ and\ current\ goal\ j-index\ and\ t2\ are\ similar,\ this\ referes\ to\ the\ current\ goal\ itself\ and\ is\ discarded\ since\ current\ goal\ to\ itself\ is\ not\ neighbour\ <br>\n\ \ \ \ \ \ \ \ \ \ (B)\:\ Check\ for\ the\ swap\ with\ neighbour\ "no-there"\ goal.\ Make\ sure\ that\ reverse\ swap\ not\ allowed.\ For\ which\ check\ that\ in\ the\ same\ call\ to\ the\ method,\ current\ goal\ is\ not\ equal\ to\ its\ original\ location\ before\ the\ earlier\ swap\ <br>\n\ \ \ \ \ \ \ \ \ \ (C)\:\ Check\ for\ the\ swap\ with\ neighbour\ moveable\ "is-there"\ goal.\ Make\ sure\ that\ reverse\ swap\ not\ allowed.\ For\ which\ check\ that\ in\ the\ same\ call\ to\ the\ method,\ current\ goal\ is\ not\ equal\ to\ its\ original\ location\ before\ the\ earlier\ swap\ <br>\ <br>\ \n\ Step4\:\ If\ conditions\ in\ Step3B/3C\ are\ satisfied\ <br>\n\ \ \ \ \ \ \ \ \ \ (A)\:\ Put\ the\ swapped\ current\ goal\ "is-there"\ in\ the\ 2D\ array\ log\ to\ check\ reverse\ swap\ in\ the\ same\ call\ of\ the\ method\ <br>\n\ \ \ \ \ \ \ \ \ \ (B)\:\ Put\ current\ goal\ (array\ cell)\ in\ temp\ <br>\n\ \ \ \ \ \ \ \ \ \ (C)\:\ Swap\ the\ current\ goal\ with\ the\ "not\ there"\ goal\ or\ with\ moveable\ "is-there"\ goal\ <br>\n\ \ \ \ \ \ \ \ \ \ (C)\:\ Put\ the\ temp\ in\ "not-there"\ or\ moveable\ "is-there"\ goal\ <br>\ <br>\ \n\ Debug\ mode\:\ change\ debug\ variable\ to\ true\ in\ function\ updateGoalPositions\ to\ see\ the\ littel\ bit\ more\ working\ details\ of\ the\ function\ <br>\ <br>\ <br>\n\n\ There\ are\ three\ difficulty\ levels\:\ <br>\n\ \ Level\ 1\:\ All\ the\ goals\ are\ stationary\ <br>\n\ \ Level\ 2\:\ Half\ of\ the\ goals\ are\ stationary\ and\ half\ are\ moveable\ <br>\n\ \ Level\ 3\:\ All\ the\ goas\ are\ moveable\ <br>\n\ @param\ goals\ 2D\ array\ of\ goals\n
comment2.params=highScoreRecords\ name\ level\ score
comment2.target=comp102x.assignment.GameRecord[]\ updateHighScoreRecords(comp102x.assignment.GameRecord[],\ java.lang.String,\ int,\ int)
comment2.text=\n\ The\ method\ compares\ the\ record\ of\ the\ current\ game\ player\ with\ those\ of\ previous\ game(s)\ played\ and\ update\ the\ highscore\ records.\n\ \n\ @param\ highScoreRecords\ The\ array\ of\ previous\ players\ records.\n\ @param\ name\ The\ name\ of\ the\ current\ player.\n\ @param\ level\ The\ level\ current\ player\ played.\n\ @param\ score\ The\ score\ current\ player\ has\ made.\n\ @return\ Array\ of\ top\ 10\ high\ score\ records.\n
numComments=3
